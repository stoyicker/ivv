final def daggerVersion = '2.22.1'
final def espressoVersion = '3.0.2'
final def testRulesVersion = '1.0.2'
final def jsr250Version = '1.0'
final def jUnitVersion = '4.12'
final def kotlinVersion = rootProject.ext.kotlinVersion
final def mockkVersion = '1.9.3'
final def picassoVersion = '2.71828'
final def retrofitVersion = '2.5.0'
final def rxAndroidVersion = '2.1.1'
final def rxJavaVersion = '2.2.8'
// Store is a reactive cache management framework available at https://github.com/nytimes/Store
// I wrote their Kotlin DSL artifacts so I thought I might as well show off a bit!
final def storeVersion = '3.1.1'
final def supportVersion = '28.0.0'
// test-accessors is a couple of annotation processors I wrote that generate code to access
// fields from tests that would be otherwise inaccessible. Think of it as a safer version of
// @VisibleForTesting
// In _splash, these are used to access a private field from tests, and in other modules to inject
// factories for the Dagger components. In a more traditional project you may have seen the
// application class be used as a DI root for the entire app and then in instrumented tests replace
// the runner with one which invokes a test-specific application instance that replaces production
// components with the desired replacements for testing. This approach is not appropriate for this
// project as it would require that every module leaks the boundary of its dependency graph to
// _splash, which is where the application class lives, killing one of the pros of this1
// architectural approach: feature independence. To avoid this, instead of using the application as
// DI root, each module has its own DI root(s), which live in activities, and just like in the
// application-as-root approach, are implemented via factory methods. During instrumented testing,
// these methods are replaced by alternatives that return test components before launching the
// target activity, achieving the same goal but this time respecting the architecture.
final def testAccessorsVersions = '1.1.4'
final def moshiVersion = '1.8.0'
final def rxJavaExtensionsVersion = '0.20.8'

ext {
  implementationDependencies = [
      "org.jetbrains.kotlin:kotlin-stdlib:$kotlinVersion",
      "com.github.stoyicker.test-accessors:annotations:$testAccessorsVersions",
      "com.android.support:appcompat-v7:$supportVersion"
  ]
  testImplementationDependencies = [
      "junit:junit:$jUnitVersion",
      "io.mockk:mockk:$mockkVersion"
  ]
  kaptDependencies = [
      "com.github.stoyicker.test-accessors:processor-kotlin:$testAccessorsVersions"
  ]
  androidTestImplementationDependencies = [
      "com.android.support.test.espresso:espresso-core:$espressoVersion",
      "com.android.support.test:rules:$testRulesVersion",
      "io.mockk:mockk-android:$mockkVersion"
  ]
  implementationListDependencies = [
      "com.android.support:design:$supportVersion",
      "com.squareup.picasso:picasso:$picassoVersion",
      "io.reactivex.rxjava2:rxjava:$rxJavaVersion",
      "com.github.akarnokd:rxjava2-extensions:$rxJavaExtensionsVersion",
      "io.reactivex.rxjava2:rxandroid:$rxAndroidVersion",
      "com.google.dagger:dagger:$daggerVersion",
      "com.nytimes.android:store3:$storeVersion",
      "com.nytimes.android:store-kotlin3:$storeVersion",
      "com.nytimes.android:middleware-moshi3:$storeVersion",
      "com.nytimes.android:filesystem3:$storeVersion",
      "com.squareup.moshi:moshi:$moshiVersion",
      "com.squareup.retrofit2:retrofit:$retrofitVersion",
      "com.squareup.retrofit2:adapter-rxjava2:$retrofitVersion",
      "com.squareup.retrofit2:converter-moshi:$retrofitVersion",
  ]
  compileOnlyListDependencies = [
      "javax.annotation:jsr250-api:$jsr250Version"
  ]
  kaptListDependencies = [
      "com.google.dagger:dagger-compiler:$daggerVersion"
  ]
  kaptAndroidTestListDependencies = [
      "com.google.dagger:dagger-compiler:$daggerVersion"
  ]
}
