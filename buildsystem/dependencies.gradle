final def daggerVersion = '2.22.1'
final def espressoVersion = '3.0.2'
final def testRulesVersion = '1.0.2'
final def jsr250Version = '1.0'
final def jUnitVersion = '4.12'
final def kotlinVersion = rootProject.ext.kotlinVersion
final def mockitoVersion = '2.27.0'
final def picassoVersion = '2.71828'
final def retrofitVersion = '2.5.0'
final def rxAndroidVersion = '2.1.1'
final def rxJavaVersion = '2.2.8'
// Store is a reactive cache management framework available at https://github.com/nytimes/Store
// I wrote their Kotlin DSL artifacts so I thought I might as well show off a bit!
final def storeVersion = '3.1.1'
final def supportVersion = '28.0.0'
// test-accessors is a couple of annotation processors I wrote that generate code to access
// fields from tests that would be otherwise inaccessible. Think of a better version of
// @VisibleForTesting
// In _splash, these are used to inject factories for unit testing, and in other modules to inject
// factories for the Dagger components. In a more traditional project you may have seen the
// application class be used as a DI root for the entire app and then in instrumented tests replace
// the runner with one which invokes a test-specific application instance that replaces production
// components with the desired replacements for testing. This approach is not appropriate for this
// project as it would require that every module leaks the boundary of its dependency graph to
// _splash, which is where the application class lives, killing one of the pros of this1
// architectural approach: feature independence. To avoid this, instead of using the application as
// DI root, each module has its own DI root(s), which live in activities, and just like in the
// application-as-root approach, are implemented via factory methods. During instrumented testing,
// these methods are replaced by alternatives that return test components before launching the
// target activity, achieving the same goal but this time respecting the architecture.
final def testAccessorsVersions = '1.1.3'

ext {
  implementationDependencies = [
      "org.jetbrains.kotlin:kotlin-stdlib:$kotlinVersion"
  ]
  testImplementationDependencies = [
      "junit:junit:$jUnitVersion",
      "org.mockito:mockito-core:$mockitoVersion"
  ]
  implementationSplashDependencies = [
      "com.github.stoyicker.test-accessors:annotations:$testAccessorsVersions",
      "com.android.support:appcompat-v7:$supportVersion"
  ]
  androidTestImplementationSplashDependencies = [
      "com.android.support.test.espresso:espresso-core:$espressoVersion",
      "com.android.support.test:rules:$testRulesVersion"
  ]
  kaptSplashDependencies = [
      "com.github.stoyicker.test-accessors:processor-kotlin:$testAccessorsVersions"
  ]
}
